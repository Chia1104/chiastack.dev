---
title: Chat
description: Chat feature state management
---

`@chiastack/features/chat` provides a feature-complete chat state management solution with support for message management, streaming, multi-threading, and more.

## Installation

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab value="npm">
    ```bash
    npm install @chiastack/features
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm add @chiastack/features
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn add @chiastack/features
    ```
  </Tab>
  <Tab value="bun">
    ```bash
    bun add @chiastack/features
    ```
  </Tab>
</Tabs>

## Import

```typescript
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';
import { MessageRole } from '@chiastack/features/chat/enums/message-role.enum';
import { ChatStatus } from '@chiastack/features/chat/enums/chat-status.enum';
```

## Basic Concepts

Chat Store is a generic state management solution that allows you to customize:

- **MessageItem**: The type of message items
- **TStreamRequestDTO**: The type of stream request data transfer objects
- **TContext**: The type of context data

## Basic Usage

### 1. Define Chat Store

First, use `defineChatStore` to define your chat store:

```typescript
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';

// Define message processor
const messageProcessor = async ({ set, get, ctx, response }) => {
  // response is an async iterable containing stream data
  for await (const chunk of response) {
    // Process each stream chunk
    const lastMessage = get().getLastMessage();
    if (lastMessage) {
      get().updateLastMessageContent(
        (lastMessage.content || '') + chunk
      );
    }
  }
};

// Define store
const { ChatStoreProvider, useChatStore } = defineChatStore({
  messageProcessor,
  enableDevtools: true, // Enable DevTools in development
});
```

### 2. Use Provider

Use `ChatStoreProvider` in your application:

```tsx
function App() {
  return (
    <ChatStoreProvider>
      <ChatInterface />
    </ChatStoreProvider>
  );
}
```

### 3. Use Store

Use the `useChatStore` Hook in your components:

```tsx
function ChatInterface() {
  const messages = useChatStore((state) => state.items);
  const handleSubmit = useChatStore((state) => state.handleSubmit);
  const status = useChatStore((state) => state.status);

  return (
    <div>
      <div>
        {messages.map((message) => (
          <div key={message.id}>
            <strong>{message.role}:</strong> {message.content}
          </div>
        ))}
      </div>
      <button onClick={() => handleSubmit('Hello!')}>Send Message</button>
      <div>Status: {status}</div>
    </div>
  );
}
```

## API Reference

### defineChatStore

Function to define and create a Chat Store.

#### Syntax

```typescript
defineChatStore<TMessageItem, TStreamRequestDTO, TContext>({
  initState?: Partial<ChatState>,
  messageProcessor: (context: {
    set: (partial: Partial<ChatState>, replace?: boolean, action?: string) => void;
    get: () => ChatStore<TMessageItem, TStreamRequestDTO, TContext>;
    ctx: unknown;
    response: AsyncIterable<string>;
  }) => Promise<void>,
  enableDevtools?: boolean,
})
```

#### Parameters

- `initState` (optional): Partial initial state values
- `messageProcessor`: Message processor function to handle received messages. Receives an object containing `set`, `get`, `ctx`, and `response`
- `enableDevtools` (optional): Whether to enable Redux DevTools (defaults to false)

#### Return Value

Returns an object containing:
- `ChatStoreProvider`: React Context Provider, used to wrap components that need to use the store
- `useChatStore`: Hook for accessing the store
- `ChatStoreContext`: Store Context (advanced use)
- `creator`: Store creator function (advanced use), used to create stores in non-React environments

### useChatStore

Hook for accessing and manipulating the Chat Store.

#### Syntax

```typescript
const value = useChatStore<T>(
  selector: (store: ChatStore) => T,
  name?: string
): T
```

**Parameters:**
- `selector`: Selector function to select the desired value from the store
- `name` (optional): Name of the hook for error messages, defaults to `"useChatStore"`

**Returns:**
- The value returned by the selector function

**Example:**

```typescript
// Get all messages
const messages = useChatStore((state) => state.items);

// Get status
const status = useChatStore((state) => state.status);

// Get input value
const input = useChatStore((state) => state.input);

// Get submit handler
const handleSubmit = useChatStore((state) => state.handleSubmit);
```

### MessageItem

Basic type definition for message items:

```typescript
interface MessageItem {
  id: string;
  content: string | null;
  rawContent?: string | null;
  createdAt: Date;
  error: any | null;
  parentId: string | null;
  reasoning?: ModelReasoning | null;
  role: MessageRole;
  threadId: string;
  toolCalls?: ToolCall[];
  context?: unknown;
}
```

### MessageRole

Message role enumeration:

```typescript
enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system',
}
```

### ChatStatus

Chat status enumeration:

```typescript
const ChatStatus = {
  Idle: "idle",
  Streaming: "streaming",
  Error: "error",
  Success: "success",
  Searching: "searching",
} as const;
```

**Status Descriptions:**
- `Idle`: Idle state, no operations in progress
- `Streaming`: Receiving stream data
- `Error`: An error occurred
- `Success`: Operation completed successfully
- `Searching`: Searching (for scenarios that require search functionality)

## Advanced Usage

### Custom MessageItem

You can extend the `MessageItem` type to fit your needs:

```typescript
import type { MessageItem } from '@chiastack/features/chat/types';

interface CustomMessageItem extends MessageItem {
  customField?: string;
  metadata?: Record<string, unknown>;
}

const { ChatStoreProvider, useChatStore } = defineChatStore<CustomMessageItem>({
  messageProcessor: async ({ set, get, ctx, response }) => {
    // response is an async iterable
    const lastMessage = get().getLastMessage();
    
    for await (const chunk of response) {
      // Process stream chunks
      if (lastMessage && lastMessage.customField) {
        console.log('Custom field:', lastMessage.customField);
      }
      if (lastMessage) {
        get().updateLastMessageContent(
          (lastMessage.content || '') + chunk
        );
      }
    }
  },
});
```

### Stream Processing

Chat Store has built-in support for stream message processing. The `messageProcessor` receives an async iterable `response` that you can directly iterate:

```typescript
const messageProcessor = async ({ set, get, ctx, response }) => {
  const lastMessage = get().getLastMessage();
  
  for await (const chunk of response) {
    // Process each stream chunk
    if (lastMessage) {
      get().updateLastMessageContent(
        (lastMessage.content || '') + chunk
      );
    }
  }
  
  // After stream completes, update status
  set({ status: ChatStatus.Idle, isPending: false });
};
```

If you need to use the `fetchStream` utility function directly (e.g., in custom request handling), you can do so:

```typescript
import { fetchStream } from '@chiastack/features/utils/stream';

const stream = await fetchStream('/api/chat/stream', {
  message: 'Hello',
  threadId: 'thread-123',
});

for await (const chunk of stream) {
  // Process stream data
  console.log('Received data:', chunk);
}
```

### Multi-threading Support

Chat Store supports multi-threading functionality, allowing you to create different threads for different conversations:

```typescript
// Get messages for a specific thread
const messages = useChatStore((state) => 
  state.items.filter((msg) => msg.threadId === 'thread-123')
);

// Switch thread
const setThreadId = useChatStore((state) => state.setThreadId);
setThreadId('thread-123');

// Get current thread ID
const threadId = useChatStore((state) => state.threadId);
```

## Utility Functions

### DEFAULT_THREAD_ID

Default thread ID:

```typescript
import { DEFAULT_THREAD_ID } from '@chiastack/features/chat/utils';

const threadId = DEFAULT_THREAD_ID; // 'inbox'
```

## Complete Example

```tsx
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';
import { MessageRole } from '@chiastack/features/chat/enums/message-role.enum';
import { ChatStatus } from '@chiastack/features/chat/enums/chat-status.enum';

// Define store
const { ChatStoreProvider, useChatStore } = defineChatStore({
  messageProcessor: async ({ set, get, ctx, response }) => {
    // response is a stream response that can be directly iterated
    const lastMessage = get().getLastMessage();
    
    for await (const chunk of response) {
      // Process each stream chunk
      if (lastMessage) {
        get().updateLastMessageContent(
          (lastMessage.content || '') + chunk
        );
      }
    }
    
    // After stream completes, update status
    set({ status: ChatStatus.Idle, isPending: false });
  },
  enableDevtools: process.env.NODE_ENV === 'development',
});

function App() {
  return (
    <ChatStoreProvider>
      <ChatApp />
    </ChatStoreProvider>
  );
}

function ChatApp() {
  const messages = useChatStore((state) => state.items);
  const handleSubmit = useChatStore((state) => state.handleSubmit);
  const status = useChatStore((state) => state.status);
  const inputValue = useChatStore((state) => state.input);
  const setInputValue = useChatStore((state) => state.setInput);

  return (
    <div>
      <h1>Chat Interface</h1>
      
      <div>
        {messages.map((message) => (
          <div key={message.id}>
            <strong>{message.role}:</strong> {message.content}
            <small>{new Date(message.createdAt).toLocaleTimeString()}</small>
          </div>
        ))}
      </div>

      <div>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}
          placeholder="Enter message..."
          disabled={status === 'loading'}
        />
        <button onClick={() => handleSubmit()} disabled={status === 'loading'}>
          Send
        </button>
      </div>

      {status === 'loading' && <div>Processing...</div>}
    </div>
  );
}
```

## Notes

- `useChatStore` must be used within `ChatStoreProvider`, otherwise it will throw an error
- `messageProcessor` is required and is used to process received messages
- The store uses Zustand's DevTools integration, which can be debugged with Redux DevTools in development
- Messages automatically get unique IDs and timestamps
- Supports error handling and retry mechanisms

