---
title: Chat
description: 聊天功能狀態管理
---

`@chiastack/features/chat` 提供了一個功能完整的聊天狀態管理解決方案，支援訊息管理、串流處理、多執行緒等功能。

## 安裝

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']}>
  <Tab value="npm">
    ```bash
    npm install @chiastack/features
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm add @chiastack/features
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn add @chiastack/features
    ```
  </Tab>
  <Tab value="bun">
    ```bash
    bun add @chiastack/features
    ```
  </Tab>
</Tabs>

## 匯入

```typescript
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';
import { MessageRole } from '@chiastack/features/chat/enums/message-role.enum';
import { ChatStatus } from '@chiastack/features/chat/enums/chat-status.enum';
```

## 基本概念

Chat Store 是一個泛型狀態管理解決方案，允許你自訂：

- **MessageItem**: 訊息項目的型別
- **TStreamRequestDTO**: 串流請求的資料傳輸物件型別
- **TContext**: 上下文資料型別

## 基本使用

### 1. 定義 Chat Store

首先，使用 `defineChatStore` 定義你的聊天 Store：

```typescript
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';

// 定義訊息處理器
const messageProcessor = async ({ set, get, ctx, response }) => {
  // response 是一個 async iterable，包含串流資料
  for await (const chunk of response) {
    // 處理每個串流區塊
    const lastMessage = get().getLastMessage();
    if (lastMessage) {
      get().updateLastMessageContent(
        (lastMessage.content || '') + chunk
      );
    }
  }
};

// 定義 Store
const { ChatStoreProvider, useChatStore } = defineChatStore({
  messageProcessor,
  enableDevtools: true, // 開發時啟用 DevTools
});
```

### 2. 使用 Provider

在應用程式中使用 `ChatStoreProvider`：

```tsx
function App() {
  return (
    <ChatStoreProvider>
      <ChatInterface />
    </ChatStoreProvider>
  );
}
```

### 3. 使用 Store

在元件中使用 `useChatStore` Hook：

```tsx
function ChatInterface() {
  const messages = useChatStore((state) => state.items);
  const handleSubmit = useChatStore((state) => state.handleSubmit);
  const status = useChatStore((state) => state.status);

  return (
    <div>
      <div>
        {messages.map((message) => (
          <div key={message.id}>
            <strong>{message.role}:</strong> {message.content}
          </div>
        ))}
      </div>
      <button onClick={() => handleSubmit('Hello!')}>發送訊息</button>
      <div>狀態: {status}</div>
    </div>
  );
}
```

## API 參考

### defineChatStore

定義並建立 Chat Store 的函式。

#### 語法

```typescript
defineChatStore<TMessageItem, TStreamRequestDTO, TContext>({
  initState?: Partial<ChatState>,
  messageProcessor: (context: {
    set: (partial: Partial<ChatState>, replace?: boolean, action?: string) => void;
    get: () => ChatStore<TMessageItem, TStreamRequestDTO, TContext>;
    ctx: unknown;
    response: AsyncIterable<string>;
  }) => Promise<void>,
  enableDevtools?: boolean,
})
```

#### 參數

- `initState` (可選): 初始狀態的部分值
- `messageProcessor`: 訊息處理器函式，用於處理收到的訊息。接收一個包含 `set`, `get`, `ctx`, `response` 的物件
- `enableDevtools` (可選): 是否啟用 Redux DevTools（預設為 false）

#### 返回值

返回一個物件，包含：
- `ChatStoreProvider`: React Context Provider，用於包裹需要使用 store 的元件
- `useChatStore`: 用於存取 Store 的 Hook
- `ChatStoreContext`: Store Context（進階使用）
- `creator`: Store 建立函式（進階使用），用於在非 React 環境中建立 store

### useChatStore

用於存取和操作 Chat Store 的 Hook。

#### 語法

```typescript
const value = useChatStore<T>(
  selector: (store: ChatStore) => T,
  name?: string
): T
```

**參數：**
- `selector`: 選擇器函數，用於從 store 中選擇需要的值
- `name` (可選): Hook 的名稱，用於錯誤訊息，預設為 `"useChatStore"`

**回傳值：**
- 選擇器函數返回的值

**範例：**

```typescript
// 獲取所有訊息
const messages = useChatStore((state) => state.items);

// 獲取狀態
const status = useChatStore((state) => state.status);

// 獲取輸入值
const input = useChatStore((state) => state.input);

// 獲取提交處理函數
const handleSubmit = useChatStore((state) => state.handleSubmit);
```

### MessageItem

訊息項目的基本型別定義：

```typescript
interface MessageItem {
  id: string;
  content: string | null;
  rawContent?: string | null;
  createdAt: Date;
  error: any | null;
  parentId: string | null;
  reasoning?: ModelReasoning | null;
  role: MessageRole;
  threadId: string;
  toolCalls?: ToolCall[];
  context?: unknown;
}
```

### MessageRole

訊息角色枚舉：

```typescript
enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system',
}
```

### ChatStatus

聊天狀態枚舉：

```typescript
const ChatStatus = {
  Idle: "idle",
  Streaming: "streaming",
  Error: "error",
  Success: "success",
  Searching: "searching",
} as const;
```

**狀態說明：**
- `Idle`: 閒置狀態，沒有正在進行的操作
- `Streaming`: 正在接收串流資料
- `Error`: 發生錯誤
- `Success`: 操作成功完成
- `Searching`: 正在搜尋（用於需要搜尋功能的場景）

## 進階使用

### 自訂 MessageItem

你可以擴展 `MessageItem` 型別以符合你的需求：

```typescript
import type { MessageItem } from '@chiastack/features/chat/types';

interface CustomMessageItem extends MessageItem {
  customField?: string;
  metadata?: Record<string, unknown>;
}

const { ChatStoreProvider, useChatStore } = defineChatStore<CustomMessageItem>({
  messageProcessor: async (message: CustomMessageItem) => {
    // 使用自訂欄位
    if (message.customField) {
      console.log('自訂欄位:', message.customField);
    }
  },
});
```

### 串流處理

Chat Store 內建支援串流訊息的處理。`messageProcessor` 會接收到一個 async iterable 的 `response`，你可以直接迭代處理：

```typescript
const messageProcessor = async ({ set, get, ctx, response }) => {
  const lastMessage = get().getLastMessage();
  
  for await (const chunk of response) {
    // 處理每個串流區塊
    if (lastMessage) {
      get().updateLastMessageContent(
        (lastMessage.content || '') + chunk
      );
    }
  }
  
  // 串流完成後，更新狀態
  set({ status: ChatStatus.Idle, isPending: false });
};
```

如果你需要直接使用 `fetchStream` 工具函式（例如在自訂的請求處理中），可以這樣做：

```typescript
import { fetchStream } from '@chiastack/features/utils/stream';

const stream = await fetchStream('/api/chat/stream', {
  message: 'Hello',
  threadId: 'thread-123',
});

for await (const chunk of stream) {
  // 處理串流資料
  console.log('收到資料:', chunk);
}
```

### 多執行緒支援

Chat Store 支援多執行緒（thread）功能，可以為不同的對話建立不同的執行緒：

```typescript
// 獲取特定執行緒的訊息
const messages = useChatStore((state) => 
  state.items.filter((msg) => msg.threadId === 'thread-123')
);

// 切換執行緒
const setThreadId = useChatStore((state) => state.setThreadId);
setThreadId('thread-123');

// 獲取當前執行緒 ID
const threadId = useChatStore((state) => state.threadId);
```

## 工具函式

### DEFAULT_THREAD_ID

預設的執行緒 ID：

```typescript
import { DEFAULT_THREAD_ID } from '@chiastack/features/chat/utils';

const threadId = DEFAULT_THREAD_ID; // 'inbox'
```

## 完整範例

```tsx
import { defineChatStore } from '@chiastack/features/chat/store';
import type { MessageItem } from '@chiastack/features/chat/types';
import { MessageRole } from '@chiastack/features/chat/enums/message-role.enum';
import { ChatStatus } from '@chiastack/features/chat/enums/chat-status.enum';

// 定義 Store
const { ChatStoreProvider, useChatStore } = defineChatStore({
  messageProcessor: async ({ set, get, ctx, response }) => {
    // response 是串流回應，可以直接迭代
    const lastMessage = get().getLastMessage();
    
    for await (const chunk of response) {
      // 處理每個串流區塊
      if (lastMessage) {
        get().updateLastMessageContent(
          (lastMessage.content || '') + chunk
        );
      }
    }
    
    // 串流完成後更新狀態
    set({ status: ChatStatus.Idle, isPending: false });
  },
  enableDevtools: process.env.NODE_ENV === 'development',
});

function App() {
  return (
    <ChatStoreProvider>
      <ChatApp />
    </ChatStoreProvider>
  );
}

function ChatApp() {
  const messages = useChatStore((state) => state.items);
  const handleSubmit = useChatStore((state) => state.handleSubmit);
  const status = useChatStore((state) => state.status);
  const inputValue = useChatStore((state) => state.input);
  const setInputValue = useChatStore((state) => state.setInput);

  return (
    <div>
      <h1>聊天介面</h1>
      
      <div>
        {messages.map((message) => (
          <div key={message.id}>
            <strong>{message.role}:</strong> {message.content}
            <small>{new Date(message.createdAt).toLocaleTimeString()}</small>
          </div>
        ))}
      </div>

      <div>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}
          placeholder="輸入訊息..."
          disabled={status === 'loading'}
        />
        <button onClick={() => handleSubmit()} disabled={status === 'loading'}>
          發送
        </button>
      </div>

      {status === 'loading' && <div>處理中...</div>}
    </div>
  );
}
```

## 注意事項

- `useChatStore` 必須在 `ChatStoreProvider` 內部使用，否則會拋出錯誤
- `messageProcessor` 是必需的，用於處理收到的訊息
- Store 使用 Zustand 的 DevTools 整合，可以在開發時使用 Redux DevTools 進行除錯
- 訊息會自動分配唯一的 ID 和時間戳記
- 支援錯誤處理和重試機制

